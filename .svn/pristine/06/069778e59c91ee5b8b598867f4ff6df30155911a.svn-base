package cn.com.cdboost.collect.impl;

import cn.com.cdboost.collect.constant.ChargeAppConstant;
import cn.com.cdboost.collect.constant.ChargeConstant;
import cn.com.cdboost.collect.dao.ChargingDeductMapper;
import cn.com.cdboost.collect.dao.ChargingPayMapper;
import cn.com.cdboost.collect.dao.ChargingUseDetailedMapper;
import cn.com.cdboost.collect.dto.chargerApp.Ajax;
import cn.com.cdboost.collect.dto.param.AccountOperateVo;
import cn.com.cdboost.collect.dto.param.WxTransfers;
import cn.com.cdboost.collect.lock.Lock;
import cn.com.cdboost.collect.model.*;
import cn.com.cdboost.collect.service.*;
import cn.com.cdboost.collect.util.*;
import cn.com.cdboost.collect.vo.Result;
import org.apache.http.HttpEntity;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.ssl.SSLContexts;
import org.apache.http.util.EntityUtils;
import org.dom4j.Document;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import javax.net.ssl.SSLContext;
import javax.servlet.http.HttpServletRequest;
import java.io.*;
import java.math.BigDecimal;
import java.security.*;
import java.security.cert.CertificateException;
import java.sql.Timestamp;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.*;

@Service
public class WxChargerPayImpl implements WxChargerPayService {
    private static final Logger logger = LoggerFactory.getLogger(WxChargerPayImpl.class);
    @Autowired
    ChargingPayMapper chargingPayMapper;
    @Autowired
    ChargingUseDetailedMapper chargingUseDetailedMapper;
    @Autowired
    ChargingDeductMapper chargingDeductMapper;
    @Autowired
    private ChargingDeviceService chargingDeviceService;
    @Autowired
    private ChargingPayChemeService chargingPayChemeService;
    @Autowired
    private ChargingCstService chargingCstService;
    @Autowired
    private ChargingPayService chargingPayService;
    @Autowired
    private ChargingProjectService chargingProjectService;
    @Autowired
    private ChargingWithdrawCashService chargingWithdrawCashService;
    @Autowired
    private XMLUtil xmlUtil;

    @Value("${appId}")
    private String appId;
    @Value("${mchId}")
    private String mchId;
    @Value("${partnerkey}")
    private String partnerkey;
    @Value("${secret}")
    private String appSecret;

    /**
     * 统一下单地址
     */
    private final String WX_UNIFIEDORDER_URL="https://api.mch.weixin.qq.com/pay/unifiedorder";
    @Override
    public Ajax pay(Double pay, String ip, ChargingPayCheme chargingPayCheme, String customerGuid, String openid, HttpServletRequest request) {

        //测试，暂时写死
        String appid = "wx7f484e7b57ce4a98";
        String appsecret = "e47ceafba85961d7a2e5f45d318a5a8e";
        String mch_id = "1485651082";
        //这个参数partnerkey是在商户后台配置的一个32位的key,微信商户平台-账户设置-安全设置-api安全
        String partnerkey = "HYwu7NzyaDZ8axVYozseVqhwSP5Z3eEU";

        Ajax ajax = new Ajax();
        String orderSn=UUID.randomUUID().toString().replace("-","");
        int penny = (int)(pay*100);
        String body = "chargeApp";
        String spbill_create_ip = request.getRemoteAddr();
        System.out.println("客户端-------------------ip="+ip);

        //实例化用户充值记录对象
        ChargingPay chargingPay = new ChargingPay();
        //设置客户唯一标识
        chargingPay.setCustomerGuid(customerGuid);
        //设置用户充值金额
        if(chargingPayCheme.getPayCategory()==4){
            chargingPay.setPayMoney(BigDecimal.valueOf(chargingPayCheme.getMoney().floatValue()));
        }else{
            chargingPay.setPayMoney(BigDecimal.valueOf(pay));
        }
        //设置用户充值类型
        chargingPay.setPayCategory(chargingPayCheme.getPayCategory());
        //设置用户购买次数
        chargingPay.setBuyCnt(chargingPayCheme.getChargingCnt());
        //设置用户包月数
        //if(chargingPayCheme.getPayCategory()==2)
          //chargingPay.setNumMonths(chargingPayCheme.get);
        //设置用户openId
        chargingPay.setWebcharNo(openid);
        //设置更新时间
        chargingPay.setCreateTime(new Timestamp(System.currentTimeMillis()));
        //设置充值标志
        chargingPay.setPayFlag(orderSn);
        //设置充值状态，待支付
        chargingPay.setPayState(0);
        //设置充值流水号
        chargingPay.setSerialNum(DateUtil.getSerialNum());
        try {
            //将生成的待支付订单插入数据库
            int pay_db_success = chargingPayMapper.insertSelective(chargingPay);
            String nonceStr = StringUtil.getNonceStr();
            //判断是否添加成功
            if(pay_db_success!=0)
            {
                //加密，这里只列举必填字段
                Map<String, String> map = new HashMap<String, String>();
                map.put("body", body);//商品描述
                map.put("mch_id", mch_id);//商户平台id
                map.put("appid", appid);//公众号id
                map.put("nonce_str", nonceStr);//随机字符串
                map.put("notify_url","http://cdz.cdboost.cn/back/notify");//异步回调api
                map.put("spbill_create_ip",ip );//支付ip
                map.put("out_trade_no", orderSn);//商品订单号
                map.put("total_fee", penny+"");//真实金额
                map.put("trade_type", "JSAPI");//JSAPI、h5调用
                map.put("openid", openid);//支付用户openid

                String sign = WxPaySignatureUtils.signature(map,partnerkey);

                map.put("sign", sign);

			  /*
			  String xml = "<xml>" +
		                "<appid>"+ configApp.getAppid() +"</appid>"+
		                "<body>"+ body +"</body>"+
		                "<mch_id>"+ configApp.getPayMachid() +"</mch_id>"+
		                "<nonce_str>"+ orderSn +"</nonce_str>"+
		                "<notify_url>"+ configApp.getPayNotifyUrl() +"</notify_url>"+
		                "<openid>"+ openid +"</openid>"+
		                "<out_trade_no>"+ orderSn +"</out_trade_no>"+
		                "<spbill_create_ip>"+ spbill_create_ip +"</spbill_create_ip>"+
		                "<total_fee>"+ penny + "" +"</total_fee>"+
		                "<trade_type>JSAPI</trade_type>"+
		                "<sign>"+ sign +"</sign>"+
		             "</xml>";
		             */
                String xml = XMLBeanUtils.map2XmlString(map);

                System.out.println("发送给微信的报文："+xml);

                String response =  WxHttpUtil.sendPost(WX_UNIFIEDORDER_URL, xml, "utf-8");
                System.out.println("收到微信的报文(下单接口后返回数据)："+response);

                Map<String, String> map_unifiedorder =  XMLBeanUtils.readStringXmlOut(response);

                //验证是否统一下单成功
                if(map_unifiedorder.get("return_code").equals("SUCCESS") && map_unifiedorder.get("result_code").equals("SUCCESS") )
                {
                    //获取关键prepay_id数据进行二次签名
                    String prepay_id = map_unifiedorder.get("prepay_id");
                    System.out.println("prepay_id="+prepay_id);

                    HashMap<String, String> back = new HashMap<String, String>();
//                    String time = Long.toString(System.currentTimeMillis());
                    String timestamp = Sha1Util.getTimeStamp();
                    String tempNonceStr = StringUtil.getNonceStr();
                    back.put("appId", appid);
                    back.put("timeStamp", timestamp);
                    back.put("nonceStr", tempNonceStr);
                    back.put("package", "prepay_id=" + prepay_id);
                    back.put("signType", "MD5");
                    //二次签名后返回给前端的签名证书字符串
                    String sign2 = WxPaySignatureUtils.signature(back, partnerkey);

//                    JSONObject jsonObject = new JSONObject();
//                    jsonObject.put("appId", appid);
//                    jsonObject.put("timeStamp", timestamp);
//                    jsonObject.put("nonceStr", tempNonceStr);
//                    jsonObject.put("package", "prepay_id=" + prepay_id);
//                    jsonObject.put("signType", "MD5");
//                    jsonObject.put("paySign", sign2);

                    Map<String,String> params = new HashMap<>();

                    params.put("appId", appid);
                    params.put("timeStamp", timestamp);
                    params.put("nonceStr", tempNonceStr);
                    params.put("package", "prepay_id=" + prepay_id);
                    params.put("signType", "MD5");
                    params.put("paySign", sign2);
                    ajax.setStatus(1);
                    ajax.setMessage("下单成功等待微信端支付！");
//                    ajax.setData(jsonObject);
                    ajax.setParams(params);
                    return ajax;
                }
                else
                {
                    ajax.setStatus(0);
                    ajax.setMessage(map_unifiedorder.get("return_msg"));
                    return ajax;
                }

            }

        } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        ajax.setMessage(AjaxMessage.operateSuccess);
        ajax.setStatus(1);
        return ajax;
    }

    @Override
    @Transactional
    public void notify(String outTradeNo) {
        logger.info("进入微信通知处理业务");
        ChargingPay chargingPay = chargingPayService.queryByPayFlag(outTradeNo);
        if (chargingPay.getPayState() == 1) {
            // 重复通知
            return;
        }

        Integer payCategory = chargingPay.getPayCategory();
        ChargingCst chargingCst = chargingCstService.queryByOpenId(chargingPay.getWebcharNo());
        Integer type = chargingPay.getType();
        if (type == 1) {
            // 月卡页面购买
            ChargingCst param = new ChargingCst();
            param.setId(chargingCst.getId());
            // 余额清零
            param.setRemainAmount(BigDecimal.ZERO);
            // 设置月卡次数和有效期
            param.setRemainCnt(chargingPay.getBuyCnt());
            Calendar calendar = Calendar.getInstance();
            calendar.setTime(new Date()); // 设置为当前时间
            calendar.set(Calendar.MONTH, calendar.get(Calendar.MONTH) + 1); // 设置为下一个月
            param.setExpireTime(calendar.getTime());
            param.setUpdateTime(new Date());

            AccountOperateVo operateVo = new AccountOperateVo();
            String guid = UuidUtil.getUuid();
            operateVo.setGuid(guid);
            operateVo.setAccountId(chargingCst.getId());
            BigDecimal amount = MathUtil.negate(chargingPay.getAccountDeductMoney());
            operateVo.setAmount(amount);
            operateVo.setReamrk("月卡购买账户余额充值操作");
            operateVo.setBusinessType(payCategory);
            chargingCstService.updateAccountNew(param,operateVo);

            ChargingPay updatePayParam = new ChargingPay();
            updatePayParam.setId(chargingPay.getId());
            updatePayParam.setUpdateTime(new Date());
            //将更新的订单状态
            updatePayParam.setPayState(1);
            // 充值后剩余金额
            updatePayParam.setAfterRemainAmount(BigDecimal.ZERO);
            chargingPayService.updateByPrimaryKeySelective(updatePayParam);
        } else if (type == 2) {
            // 活动页面购买
            ChargingCst param = new ChargingCst();
            param.setId(chargingCst.getId());
            //设置更新时间
            param.setUpdateTime(new Date());
            // 充值后剩余金额
            BigDecimal remainAmount = chargingCst.getRemainAmount().add(chargingPay.getAccountChargeMoney());
            param.setRemainAmount(remainAmount);

            // 更新账户并记录流水
            AccountOperateVo operateVo = new AccountOperateVo();
            String guid = UuidUtil.getUuid();
            operateVo.setGuid(guid);
            operateVo.setAccountId(chargingCst.getId());
            operateVo.setAmount(chargingPay.getAccountChargeMoney());
            operateVo.setReamrk("活动页面购买余额");
            operateVo.setBusinessType(payCategory);
            chargingCstService.updateAccountNew(param,operateVo);

            ChargingPay updatePayParam = new ChargingPay();
            updatePayParam.setId(chargingPay.getId());
            updatePayParam.setUpdateTime(new Date());
            //将更新的订单状态
            updatePayParam.setPayState(1);
            updatePayParam.setAfterRemainAmount(remainAmount);
            chargingPayService.updateByPrimaryKeySelective(updatePayParam);
        } else {
            // 更新充值用户相关信息
            // 判断是否是包月数据，若是包月用户则更新剩余次数
            ChargingCst param = new ChargingCst();
            param.setId(chargingCst.getId());
            BigDecimal afterRemainAmount = null;

            AccountOperateVo operateVo = new AccountOperateVo();
            operateVo.setAccountId(chargingCst.getId());
            String guid = UuidUtil.getUuid();
            operateVo.setGuid(guid);
            if(ChargeConstant.SchemePayCategory.MONTH_RECHARGE.getType().equals(payCategory)) {
                param.setRemainCnt(chargingPay.getBuyCnt());
                Calendar calendar = Calendar.getInstance();
                calendar.setTime(new Date()); // 设置为当前时间
                calendar.set(Calendar.MONTH, calendar.get(Calendar.MONTH) + 1); // 设置为下一个月
                param.setExpireTime(calendar.getTime());
                afterRemainAmount = chargingCst.getRemainAmount();

                operateVo.setBusinessType(payCategory);
                operateVo.setChargeCnt(chargingPay.getBuyCnt());
                operateVo.setExpireTime(calendar.getTime());
                operateVo.setReamrk(ChargeConstant.SchemePayCategory.MONTH_RECHARGE.getDesc());
            } else {
                //设置剩余金额
                BigDecimal remainAmount = chargingCst.getRemainAmount().add(chargingPay.getAccountChargeMoney());
                param.setRemainAmount(MathUtil.setPrecision(remainAmount));
                afterRemainAmount = remainAmount;

                operateVo.setBusinessType(payCategory);
                operateVo.setAmount(chargingPay.getAccountChargeMoney());
                String descByType = ChargeConstant.SchemePayCategory.getDescByType(payCategory);
                operateVo.setReamrk(descByType);
            }
            //设置更新时间
            param.setUpdateTime(new Date());

            // 更新账户并记录流水
            chargingCstService.updateAccountNew(param,operateVo);

            ChargingPay updatePayParam = new ChargingPay();
            updatePayParam.setId(chargingPay.getId());
            updatePayParam.setUpdateTime(new Date());
            // 将更新的订单状态
            updatePayParam.setPayState(1);
            // 充值后剩余金额
            updatePayParam.setAfterRemainAmount(afterRemainAmount);
            chargingPayService.updateByPrimaryKeySelective(updatePayParam);
        }
    }

    @Override
    @Transactional
    public void deductions(String chargingGuid, String deviceNo,String port,String openId,String priceId) {
        // 查询充电桩设备
        ChargingDevice chargingDevice = chargingDeviceService.queryByDeviceNo(deviceNo,port);

        //获取价格方案
        ChargingPayCheme chargingPayCheme = chargingPayChemeService.selectByPrimaryKey(Integer.parseInt(priceId));

        // 客户信息
        ChargingCst chargingCst = chargingCstService.queryByOpenId(openId);

        Integer payCategory = chargingPayCheme.getPayCategory();
        if(ChargeConstant.SchemePayCategory.TEMPORARY_RECHARGE.getType().equals(payCategory) || ChargeConstant.SchemePayCategory.RECHARGE_FULL.getType().equals(payCategory)){
            //临时用户，则扣除相应金额
            AccountOperateVo operateVo = new AccountOperateVo();
            operateVo.setGuid(chargingGuid);
            operateVo.setAccountId(chargingCst.getId());
            operateVo.setBusinessType(payCategory);
            BigDecimal amount = MathUtil.negate(chargingPayCheme.getMoney());
            operateVo.setAmount(amount);
            String descByType = ChargeConstant.SchemePayCategory.getDescByType(payCategory);
            operateVo.setReamrk(descByType);
//            chargingCstService.updateAccount(operateVo);

            BigDecimal remainAmount = chargingCst.getRemainAmount().subtract(chargingPayCheme.getMoney());
            ChargingCst param = new ChargingCst();
            param.setId(chargingCst.getId());
            param.setRemainAmount(remainAmount);
            param.setUpdateTime(new Date());
            chargingCstService.updateAccountNew(param,operateVo);
//            this.deductChargeCst4TempUser(chargingCst,remainAmount);

            // 维护充电桩使用记录表
            this.addUseDetailedRecord4TempUser(chargingCst,chargingDevice,chargingPayCheme,openId,chargingGuid,remainAmount);

            // 维护客户扣费记录表
            this.addChargingDeductRecord4TempUser(chargingCst,chargingPayCheme,chargingGuid,remainAmount);
        } else if(ChargeConstant.SchemePayCategory.MONTH_RECHARGE.getType().equals(payCategory)){
            //包月用户扣除次数
            AccountOperateVo accountOperateVo = new AccountOperateVo();
            accountOperateVo.setGuid(chargingGuid);
            accountOperateVo.setAccountId(chargingCst.getId());
            accountOperateVo.setBusinessType(payCategory);
            accountOperateVo.setChargeCnt(-1);
            accountOperateVo.setReamrk("月卡消费，扣除月卡次数");
            chargingCstService.updateAccount(accountOperateVo);
            //设置剩余充电次数
            Integer remainCnt = chargingCst.getRemainCnt()-1;
//            this.deductChargeCst4MonthUser(chargingCst,remainCnt);

            // 维护充电桩使用记录表
            this.addUseDetailedRecord4MonthUser(chargingCst,chargingDevice,chargingPayCheme,openId,chargingGuid,remainCnt);

            // 维护客户扣费记录表
            this.addChargingDeductRecord4MonthUser(chargingCst,chargingGuid,remainCnt);
        }
    }

    /**
     * 用户购买月卡余额扣减
     * @param chargingCst
     * @param chargingPayCheme
     */
    @Override
    @Transactional
    public void deductionsOfMonth(ChargingCst chargingCst, ChargingPayCheme chargingPayCheme) {
        //用户需购买的次数
        Integer chargeCnt = chargingPayCheme.getChargingCnt();
        //用户扣减后的余额
        BigDecimal remainAmount = chargingCst.getRemainAmount().subtract(chargingPayCheme.getMoney());
        //用户包月过期时间
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(new Date()); // 设置为当前时间
        calendar.set(Calendar.MONTH, calendar.get(Calendar.MONTH) + 1); // 设置为下一个月
        Date expired = calendar.getTime();
        //设置更新的用户
        ChargingCst param = new ChargingCst();
        param.setId(chargingCst.getId());
        param.setRemainCnt(chargeCnt);
        param.setRemainAmount(MathUtil.setPrecision(remainAmount));
        param.setExpireTime(expired);
        param.setUpdateTime(new Date());

        AccountOperateVo operateVo = new AccountOperateVo();
        String uuid = UuidUtil.getUuid();
        operateVo.setGuid(uuid);
        operateVo.setAccountId(chargingCst.getId());
        operateVo.setBusinessType(ChargeConstant.SchemePayCategory.MONTH_RECHARGE.getType());
        BigDecimal amount = MathUtil.negate(chargingPayCheme.getMoney());
        operateVo.setAmount(amount);
        operateVo.setChargeCnt(chargeCnt);
        operateVo.setReamrk("月卡购买余额扣减操作");
        chargingCstService.updateAccountNew(param,operateVo);
    }

    /**
     * 临时用户，扣减充值方案金额
     * @param chargingCst
     * @param remainAmount 扣减后剩余金额
     */
    private void deductChargeCst4TempUser(ChargingCst chargingCst, BigDecimal remainAmount) {
        ChargingCst param = new ChargingCst();
        param.setId(chargingCst.getId());
        param.setRemainAmount(MathUtil.setPrecision(remainAmount));
        param.setUpdateTime(new Date());
        chargingCstService.updateByPrimaryKeySelective(param);
    }

    /**
     * 临时用户，扣减充值方案金额
     * @param chargingCst
     */
    private void deductChargeCst4MonthUser(ChargingCst chargingCst, Integer remainCnt) {
        ChargingCst param = new ChargingCst();
        param.setId(chargingCst.getId());
        param.setRemainCnt(remainCnt);
        param.setUpdateTime(new Date());
        chargingCstService.updateByPrimaryKeySelective(param);
    }

    /**
     * 包月用户，新增客户扣费记录表
     * @param chargingCst
     * @param chargingGuid
     * @param deductRemainCnt
     */
    private void addChargingDeductRecord4MonthUser(ChargingCst chargingCst, String chargingGuid, Integer deductRemainCnt) {
        ChargingDeduct chargingDeduct = new ChargingDeduct();
        chargingDeduct.setCustomerGuid(chargingCst.getCustomerGuid());
        chargingDeduct.setChargingGuid(chargingGuid);
        chargingDeduct.setDeductCnt(1);
        chargingDeduct.setDeductRemainCnt(deductRemainCnt);
        // 扣费前剩余金额
        chargingDeduct.setDeductBefore(chargingCst.getRemainAmount());
        // 扣费后剩余金额
        chargingDeduct.setRemainAmount(chargingCst.getRemainAmount());
        chargingDeduct.setRemark("包月用户充电扣减次数");
        chargingDeduct.setCreateTime(new Date());
        chargingDeduct.setSerialNum(DateUtil.getSerialNum());
        chargingDeductMapper.insertSelective(chargingDeduct);
    }

    /**
     * 临时用户，新增客户扣费记录表
     * @param chargingCst
     * @param chargingPayCheme
     * @param chargingGuid
     * @param afterRemainAmount
     */
    private void addChargingDeductRecord4TempUser(ChargingCst chargingCst, ChargingPayCheme chargingPayCheme, String chargingGuid, BigDecimal afterRemainAmount) {
        ChargingDeduct chargingDeduct = new ChargingDeduct();
        chargingDeduct.setCustomerGuid(chargingCst.getCustomerGuid());
        chargingDeduct.setChargingGuid(chargingGuid);
        chargingDeduct.setDeductMoney(chargingPayCheme.getMoney());
        // 扣费后剩余金额
        chargingDeduct.setRemainAmount(afterRemainAmount);
        // 扣费前剩余金额
        chargingDeduct.setDeductBefore(chargingCst.getRemainAmount());
        chargingDeduct.setCreateTime(new Date());
        chargingDeduct.setRemark("临时用户充电扣费");
        chargingDeduct.setSerialNum(DateUtil.getSerialNum());
        chargingDeductMapper.insertSelective(chargingDeduct);
    }

    /**
     * 临时用户，新增充值记录明细表
     * @param chargingCst
     * @param chargingDevice
     * @param chargingPayCheme
     * @param openId
     */
    private void addUseDetailedRecord4TempUser(ChargingCst chargingCst, ChargingDevice chargingDevice, ChargingPayCheme chargingPayCheme, String openId, String chargingGuid, BigDecimal afterRemainAmount) {
        // 查询充电桩电价
        ChargingProject chargingProject = chargingProjectService.queryByProjectGuid(chargingDevice.getProjectGuid());

        // 新增充电使用记录表
        ChargingUseDetailed detailed = new ChargingUseDetailed();
        detailed.setCustomerGuid(chargingCst.getCustomerGuid());
        detailed.setChargingPlieGuid(chargingDevice.getChargingPlieGuid());
        detailed.setWebcharNo(openId);

        Integer payCategory = chargingPayCheme.getPayCategory();
        detailed.setPayCategory(payCategory);
        if (ChargeConstant.SchemePayCategory.TEMPORARY_RECHARGE.getType().equals(payCategory)) {
            // 临时充电
            detailed.setChargingWay(1);
        } else if (ChargeConstant.SchemePayCategory.RECHARGE_FULL.getType().equals(payCategory)) {
            // 一次充满
            detailed.setChargingWay(3);
        }

        // 充电扣除费用
        detailed.setDeductMoney(chargingPayCheme.getMoney());
        // 本次充电后剩余金额
        detailed.setAfterRemainAmount(afterRemainAmount);
        detailed.setPrice(chargingProject.getPrice());
        detailed.setStartTime(new Date());
        detailed.setState(0);
        //设置充电时间
        detailed.setChargingTime(chargingPayCheme.getChargingTime());
        detailed.setChargingGuid(chargingGuid);
        detailed.setCreateTime(new Date());
        chargingUseDetailedMapper.insertSelective(detailed);
    }


    /**
     * 包月用户，新增充值记录明细表
     * @param chargingCst
     * @param chargingDevice
     * @param chargingPayCheme
     * @param openId
     */
    private void addUseDetailedRecord4MonthUser(ChargingCst chargingCst, ChargingDevice chargingDevice, ChargingPayCheme chargingPayCheme, String openId, String chargingGuid, Integer afterRemainCnt) {
        // 查询充电桩电价
        ChargingProject chargingProject = chargingProjectService.queryByProjectGuid(chargingDevice.getProjectGuid());

        // 新增充电使用记录表
        ChargingUseDetailed detailed = new ChargingUseDetailed();
        detailed.setCustomerGuid(chargingCst.getCustomerGuid());
        detailed.setChargingPlieGuid(chargingDevice.getChargingPlieGuid());
        detailed.setWebcharNo(openId);
        detailed.setPayCategory(chargingPayCheme.getPayCategory());
        // 包月用户，每次均是充满断电
        detailed.setChargingWay(3);
        detailed.setAfterRemainCnt(afterRemainCnt);

        // 充电扣除费用
        BigDecimal deductMoney = MathUtil.divide(chargingPayCheme.getMoney(), new BigDecimal(chargingPayCheme.getChargingCnt()));
        detailed.setDeductMoney(MathUtil.setPrecision(deductMoney));
        detailed.setPrice(chargingProject.getPrice());
        detailed.setStartTime(new Date());
        detailed.setState(0);
        detailed.setChargingTime(chargingPayCheme.getChargingTime());
        detailed.setChargingGuid(chargingGuid);
        detailed.setCreateTime(new Date());
        chargingUseDetailedMapper.insertSelective(detailed);
    }

    @Override
    public Ajax chargePay(Integer type,BigDecimal deductAmount,BigDecimal pay, String ip, ChargingPayCheme chargingPayCheme, String customerGuid, String openid) {
        //测试，暂时写死
        String appid = "wx7f484e7b57ce4a98";
        String appsecret = "e47ceafba85961d7a2e5f45d318a5a8e";
        String mch_id = "1485651082";
        //这个参数partnerkey是在商户后台配置的一个32位的key,微信商户平台-账户设置-安全设置-api安全
        String partnerkey = "HYwu7NzyaDZ8axVYozseVqhwSP5Z3eEU";
        String notifyUrl = "http://cdz.cdboost.cn/back/notify";

        // 总金额以分为单位，不带小数点
        String payMoney = MathUtil.yuan2Fen(String.valueOf(pay));
        String body = "chargeApp";
        System.out.println("客户端-------------------ip="+ip);

        String trade_type = "JSAPI";
        // 随机字符串
        String nonce_str = StringUtil.getNonceStr();
        DateFormat format = new SimpleDateFormat("yyyyMMddHHmmss");

        String time_start = format.format(new Date());
        // 商户订单号
        String out_trade_no = UuidUtil.getUuid();

        //String body = "微信测试支付";
        SortedMap<String, String> packageParams = new TreeMap<String, String>();
        packageParams.put("appid", appid);
        packageParams.put("body", body);
        packageParams.put("openid",openid);
        packageParams.put("time_start",time_start);
        packageParams.put("mch_id", mch_id);
        packageParams.put("nonce_str", nonce_str);
        packageParams.put("notify_url", notifyUrl);
        packageParams.put("out_trade_no", out_trade_no);
        packageParams.put("spbill_create_ip", ip);
        packageParams.put("total_fee", payMoney);
        packageParams.put("trade_type", trade_type);
        packageParams.put("sign_type", "MD5");

        RequestHandler reqHandler = new RequestHandler(null, null);
        reqHandler.init(appid,appsecret,partnerkey);

        String sign = reqHandler.createSign(packageParams);
        String xml = "<xml>"
                + "<appid>" + appid + "</appid>"
                + "<mch_id>"+ mch_id + "</mch_id>"
                + "<nonce_str>" + nonce_str+ "</nonce_str>"
                + "<body><![CDATA[" + body + "]]></body>"
                + "<time_start>" + time_start + "</time_start>"
                + "<out_trade_no>" + out_trade_no+ "</out_trade_no>"
                + "<total_fee>" + payMoney + "</total_fee>"
                + "<spbill_create_ip>" + ip+ "</spbill_create_ip>"
                + "<notify_url>" + notifyUrl+ "</notify_url>"
                + "<openid>" + openid + "</openid>"
                + "<trade_type>" + trade_type+ "</trade_type>"
                + "<sign>" + sign + "</sign>"
                + "<sign_type>MD5</sign_type>"
                + "</xml>";
        logger.info("weixin"+"-xml:"+xml);
        String createOrderURL = "https://api.mch.weixin.qq.com/pay/unifiedorder";

        String prepayId = new GetWxOrderno().getPayNo(createOrderURL, xml);
        // 预订单生成后，本地保存相应的订单号

        if(!StringUtils.isEmpty(prepayId)){
            // 查询充值前账户余额
            ChargingCst chargingCst = chargingCstService.queryByOpenId(openid);

            //实例化用户充值记录对象
            ChargingPay chargingPay = new ChargingPay();
            chargingPay.setCustomerGuid(customerGuid);
            //设置用户充值金额,单位元
            Integer payCategory = chargingPayCheme.getPayCategory();
            if(ChargeConstant.SchemePayCategory.BALANCE_RECHARGE.getType().equals(payCategory)){
                chargingPay.setPayMoney(chargingPayCheme.getPayMoney());
                chargingPay.setAccountChargeMoney(chargingPayCheme.getMoney());
            } else {
                chargingPay.setPayMoney(pay);
                chargingPay.setAccountChargeMoney(pay);
            }
            chargingPay.setAccountDeductMoney(deductAmount);
            chargingPay.setChargingTime(chargingPayCheme.getChargingTime());
            chargingPay.setPayCategory(chargingPayCheme.getPayCategory());
            chargingPay.setBuyCnt(chargingPayCheme.getChargingCnt());
            chargingPay.setWebcharNo(openid);
            chargingPay.setCreateTime(new Date());
            chargingPay.setPayFlag(out_trade_no);
            chargingPay.setPayState(0);
            chargingPay.setSerialNum(DateUtil.getSerialNum());
            // 充值后剩余金额，此处是先将充值前剩余金额赋值上，避免用户点击支付，然后又取消了，导致支付失败的订单上该字段为null
            // 充值成功后，在回调处还会更新此字段
            chargingPay.setAfterRemainAmount(chargingCst.getRemainAmount());
            chargingPay.setType(type);
            chargingPayMapper.insertSelective(chargingPay);
        }


        //获取prepay_id后，拼接最后请求支付所需要的package
        SortedMap<String, String> finalpackage = new TreeMap<String, String>();
        String timestamp = Sha1Util.getTimeStamp();
        nonce_str = StringUtil.getNonceStr();
        finalpackage.put("appId", appid);
        finalpackage.put("timeStamp", timestamp);
        finalpackage.put("nonceStr", nonce_str);
        finalpackage.put("package", "prepay_id=" + prepayId);
        finalpackage.put("signType", "MD5");
        //要签名
        String finalsign = reqHandler.createSign(finalpackage);

        Map<String,String> params = new HashMap<>();
        params.put("appId", appid);
        params.put("timeStamp", timestamp);
        params.put("nonceStr", nonce_str);
        params.put("package", "prepay_id=" + prepayId);
        params.put("signType", "MD5");
        params.put("paySign", finalsign);

        Ajax ajax = new Ajax();
        ajax.setStatus(1);
        ajax.setMessage("下单成功等待微信端支付！");
        ajax.setParams(params);
        return ajax;
    }

    @Override
    public String refund(String openId,BigDecimal amount,HttpServletRequest request) {
        logger.info("--------------微信退费接口---------------");
        String companyPayUrl = "https://api.mch.weixin.qq.com/mmpaymkttransfers/promotion/transfers";
        String mch_appid = "wx7f484e7b57ce4a98";
        String mch_id = "1485651082";
        String partnerkey = "HYwu7NzyaDZ8axVYozseVqhwSP5Z3eEU";
        //String device_info = "";
        String nonce_str = StringUtil.getNonceStr();
        String partner_trade_no = UuidUtil.getUuid();;//商户订单号
        String check_name = "NO_CHECK";//校验用户姓名选项 //	NO_CHECK：不校验真实姓名        FORCE_CHECK：强校验真实姓名
        String re_user_name = "杨家兵";//收款用户真实姓名 //如果check_name设置为FORCE_CHECK，则必填用户真实姓名
       // String amount = "1";//企业付款总金额数(分)
        String desc = "充电用户账户余额提现";//企业付款描述信息
        String spbill_create_ip = request.getRemoteAddr();//调用接口的终端ip

        Map<String, String> data = new HashMap<String, String>();
        data.put("mch_appid", mch_appid); //商户号
        data.put("mchid",mch_id);//注意这里没下划线 ,微信支付的时候这里是带下划线的,
        //data.put("device_info",device_info);
        data.put("nonce_str",nonce_str);
        data.put("partner_trade_no",partner_trade_no);
        data.put("openid",openId);
        data.put("check_name",check_name);
        data.put("re_user_name",re_user_name);
        data.put("amount",amount.toString());
        data.put("desc",desc);
        data.put("spbill_create_ip",spbill_create_ip);
        String sign = WxPaySignatureUtils.signature(data,partnerkey);
        data.put("sign",sign);

        //***********************企业付款请求*********************************

        KeyStore keyStore  = null;
        try {
            keyStore = KeyStore.getInstance("PKCS12");
        } catch (KeyStoreException e) {
            logger.error("KeyStoreException,获取keyStore异常:",e);
        }
        String certPath = "F://wx//apiclient_cert.p12";
        FileInputStream instream = null;
        try {
            instream = new FileInputStream(new File(certPath));
        } catch (FileNotFoundException e) {
            logger.error("FileNotFoundException,证书读取异常:",e);
        }
        try {
            try {
                keyStore.load(instream,mch_id.toCharArray());
            } catch (IOException e) {
                logger.error("IOException,验证异常:",e);
            } catch (NoSuchAlgorithmException e) {
                logger.error("NoSuchAlgorithmException，验证异常:",e);
            } catch (CertificateException e) {
                logger.error("CertificateException，验证异常:",e);
            }
        } finally {
            try {
                instream.close();
            } catch (IOException e) {
                logger.error("IOException，IO异常:",e);
            }
        }
        // Trust own CA and all self-signed certs
        SSLContext sslcontext = null;
        try {
            sslcontext = SSLContexts.custom().loadKeyMaterial(keyStore, mch_id.toCharArray()).build();
        } catch (NoSuchAlgorithmException e) {
            logger.error("NoSuchAlgorithmException,上下文验证异常:",e);
        } catch (KeyManagementException e) {
            logger.error("KeyManagementException,上下文验证异常:",e);
        } catch (KeyStoreException e) {
            logger.error("KeyStoreException,上下文验证异常:",e);
        } catch (UnrecoverableKeyException e) {
            logger.error("UnrecoverableKeyException,上下文验证异常:",e);
        }
        // Allow TLSv1 protocol only
        SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(sslcontext,new String[] { "TLSv1" },null,SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);
        CloseableHttpClient httpclient = HttpClients.custom().setSSLSocketFactory(sslsf).build();
        try {
            HttpPost httpPost = new HttpPost(companyPayUrl);
            httpPost.addHeader("Connection", "keep-alive");
            httpPost.addHeader("Accept", "");
            httpPost.addHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8");
            httpPost.addHeader("Host", "api.mch.weixin.qq.com");
            httpPost.addHeader("X-Requested-With", "XMLHttpRequest");
            httpPost.addHeader("Cache-Control", "max-age=0");
            httpPost.addHeader("User-Agent", "Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0) ");
            String dataXML = XMLBeanUtils.map2XmlString(data);
            httpPost.setEntity(new StringEntity(dataXML, "UTF-8"));
            logger.info("执行请求" + httpPost.getRequestLine());
            CloseableHttpResponse response = null;
            try {
                response = httpclient.execute(httpPost);
            } catch (IOException e) {
                logger.error("IOException,请求微信退费接口异常:",e);
            }
            try {
                HttpEntity entity = response.getEntity();
                logger.info("响应状态吗: " + response.getStatusLine());
                if (entity != null) {
                    logger.info("响应内容长度: " + entity.getContentLength());
                    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(entity.getContent(),"UTF-8"));
                    String text;
                    while ((text = bufferedReader.readLine()) != null) {
                        logger.info(text);
                    }

                }
                EntityUtils.consume(entity);
            } catch (UnsupportedEncodingException e) {
                logger.error("UnsupportedEncodingException,接口响应异常:",e);
            } catch (IOException e) {
                logger.error("UnsupportedEncodingException,接口响应异常:",e);
            } finally {
                try {
                    response.close();
                } catch (IOException e) {
                    logger.error("IOException,关闭响应异常:",e);
                }
            }
        } finally {
            try {
                httpclient.close();
            } catch (IOException e) {
                logger.error("IOException,关闭请求客户端异常:",e);
            }
        }
        return null;
    }


    @Override
    public Result withdrawCash(String guid,String openId, BigDecimal amount, HttpServletRequest request) {
        Lock lock = new Lock();

        Result result = new Result("提现成功");
        try {
            // 加锁
            lock.lock(openId);

            // 处理重复请求
            ChargingWithdrawCash withdrawCash = chargingWithdrawCashService.queryByGuid(guid);
            if (withdrawCash != null) {
                result.setMessage(withdrawCash.getErrorMsg());
                return result;
            }

            // 判断是否可提现
            ChargingCst chargingCst = chargingCstService.queryByOpenId(openId);
            BigDecimal remainAmount = chargingCst.getRemainAmount();
            BigDecimal subtract = remainAmount.subtract(amount);
            boolean flag = MathUtil.isLessThanZero(subtract);
            if (flag) {
                result.setMessage("账户余额不足");
                return result;
            }

            // 扣除用户账户余额
            ChargingCst updateParam = new ChargingCst();
            updateParam.setId(chargingCst.getId());
            updateParam.setRemainAmount(subtract);
            updateParam.setUpdateTime(new Date());
            chargingCstService.updateByPrimaryKeySelective(updateParam);

            // 添加一条提现记录
            ChargingWithdrawCash record = new ChargingWithdrawCash();
            record.setWebcharNo(openId);
            record.setAmount(amount);
            record.setStatus(0);
            record.setCreateTime(new Date());
            record.setGuid(guid);
            chargingWithdrawCashService.insertSelective(record);

            // 调用微信提现接口
            String companyPayUrl = "https://api.mch.weixin.qq.com/mmpaymkttransfers/promotion/transfers";
            String nonce_str = StringUtil.getNonceStr();
            String partner_trade_no = UuidUtil.getUuid();//商户订单号
            String check_name = "NO_CHECK";//校验用户姓名选项 //	NO_CHECK：不校验真实姓名        FORCE_CHECK：强校验真实姓名
            String desc = "充电用户账户余额提现";//企业付款描述信息
            String spbill_create_ip = request.getRemoteAddr();//调用接口的终端ip

            Map<String, String> data = new HashMap<>();
            data.put("mch_appid", appId); //商户号
            data.put("mchid",mchId);//注意这里没下划线 ,微信支付的时候这里是带下划线的,
            data.put("nonce_str",nonce_str);
            data.put("partner_trade_no",partner_trade_no);
            data.put("openid",openId);
            data.put("check_name",check_name);
            // 元转分
            String cashMoney = MathUtil.yuan2Fen(String.valueOf(amount));
            data.put("amount",cashMoney);
            data.put("desc",desc);
            data.put("spbill_create_ip",spbill_create_ip);
            String sign = WxPaySignatureUtils.signature(data,partnerkey);
            data.put("sign",sign);

            WxTransfers transfers = new WxTransfers();
            transfers.setMch_appid(appId);
            transfers.setMchid(mchId);
            transfers.setNonce_str(nonce_str);
            transfers.setPartner_trade_no(partner_trade_no);
            transfers.setOpenid(openId);
            transfers.setCheck_name(check_name);
            transfers.setAmount(cashMoney);
            transfers.setDesc(desc);
            transfers.setSpbill_create_ip(spbill_create_ip);
            transfers.setSign(sign);

            //***********************企业付款请求*********************************
            xmlUtil.xstream().alias("xml", WxTransfers.class);
            String xml = xmlUtil.xstream().toXML(transfers);
            String ssl = WxHttpUtil.ssl(request, companyPayUrl, mchId, xml);
            if (StringUtils.isEmpty(ssl)) {
                result.error("系统异常");
                return result;
            }

            logger.info("提现返回值：" + ssl);
            Document document = XmlUtil.getDocument(ssl);
            Map<String, String> map = new HashMap<>();
            XmlUtil.getMapByDocument(document.getRootElement(), map);

            String return_code = map.get("return_code");
            String result_code = map.get("result_code");
            if (!"SUCCESS".equals(return_code)) {
                // 通信失败
                result.setMessage("提现接口返回通信失败");
                return result;
            }

            if(!"SUCCESS".equals(result_code)) {
                logger.info("提现接口返回FAIL");
                String errCode = map.get("err_code");
                String errCodeDes = map.get("err_code_des");

                if ("SYSTEMERROR".equals(errCode)) {
                    // 这种情况，不能理解为转账失败，需要主动查询状态
                    // 更新提现记录状态
                    ChargingWithdrawCash cashParam = new ChargingWithdrawCash();
                    cashParam.setId(record.getId());
                    cashParam.setStatus(ChargeAppConstant.WithdrawCashStatus.FAIL.getStatus());
                    cashParam.setErrorCode(errCode);
                    cashParam.setErrorMsg(errCodeDes);
                    cashParam.setUpdateTime(new Date());
                    chargingWithdrawCashService.updateByPrimaryKeySelective(cashParam);

                    // 主动查询一次
                    String xmlData = this.queryTransferInfo(request,partner_trade_no);
                    if (StringUtils.isEmpty(xmlData)) {
                        result.error("系统异常");
                        return result;
                    }

                    Document document2 = XmlUtil.getDocument(xmlData);
                    Map<String, String> queryMap = new HashMap<>();
                    XmlUtil.getMapByDocument(document2.getRootElement(), queryMap);
                    String returnCode = queryMap.get("return_code");
                    String resultcode = queryMap.get("result_code");
                    if ("SUCCESS".equals(returnCode) && "SUCCESS".equals(resultcode)) {
                        String status = queryMap.get("status");
                        String reason = queryMap.get("reason");

                        if ("SUCCESS".equals(status)) {
                            // 成功
                            ChargingWithdrawCash temp = new ChargingWithdrawCash();
                            temp.setId(record.getId());
                            temp.setStatus(ChargeAppConstant.WithdrawCashStatus.SUCCESS.getStatus());
                            temp.setUpdateTime(new Date());
                            chargingWithdrawCashService.updateByPrimaryKeySelective(temp);
                            return result;
                        } else if("PROCESSING".equals(status)) {
                            // 处理中
                            result.setMessage("处理中");
                            return result;
                        } else {
                            // 转账失败
                            ChargingWithdrawCash temp = new ChargingWithdrawCash();
                            temp.setId(record.getId());
                            temp.setStatus(ChargeAppConstant.WithdrawCashStatus.FAIL.getStatus());
                            temp.setErrorMsg(reason);
                            temp.setUpdateTime(new Date());
                            chargingWithdrawCashService.updateByPrimaryKeySelective(temp);
                            result.setMessage("提现失败");
                            return result;
                        }
                    }

                    // 直接返回
                    result.error("系统繁忙");
                    return result;
                } else {
                    // 扣减的余额加回去
                    ChargingCst cstParam = new ChargingCst();
                    cstParam.setId(chargingCst.getId());
                    cstParam.setRemainAmount(remainAmount);
                    cstParam.setUpdateTime(new Date());
                    chargingCstService.updateByPrimaryKeySelective(cstParam);

                    // 更新提现记录状态
                    ChargingWithdrawCash cashParam = new ChargingWithdrawCash();
                    cashParam.setId(record.getId());
                    cashParam.setStatus(ChargeAppConstant.WithdrawCashStatus.FAIL.getStatus());
                    cashParam.setErrorCode(errCode);
                    cashParam.setErrorMsg(errCodeDes);
                    cashParam.setUpdateTime(new Date());
                    chargingWithdrawCashService.updateByPrimaryKeySelective(cashParam);

                    result.setMessage(errCodeDes);
                    return result;
                }
            }

            // 提现成功处理逻辑
            String partnerTradeNo = map.get("partner_trade_no");
            String paymentTime = map.get("payment_time");

            ChargingWithdrawCash cashParam = new ChargingWithdrawCash();
            cashParam.setId(record.getId());
            cashParam.setPartnerTradeNo(partnerTradeNo);
            cashParam.setStatus(ChargeAppConstant.WithdrawCashStatus.SUCCESS.getStatus());
            cashParam.setUpdateTime(new Date());
            chargingWithdrawCashService.updateByPrimaryKeySelective(cashParam);
            return result;
        } catch (Exception e) {
            logger.error("提现接口异常",e);
            result.error("系统异常");
        } finally {
            lock.unLock();
        }
        return result;
    }

    @Override
    public void checkCashFailFlows(Integer id,String partnerTradeNo) {
        String url = "https://api.mch.weixin.qq.com/mmpaymkttransfers/gettransferinfo";
        String nonceStr = StringUtil.getNonceStr();
        Map<String, String> data = new HashMap<>();
        data.put("mch_id", mchId);
        data.put("appid",appId);
        data.put("nonce_str",nonceStr);
        data.put("partner_trade_no",partnerTradeNo);

        String sign = WxPaySignatureUtils.signature(data,partnerkey);
        data.put("sign",sign);

        String dataXML = XMLBeanUtils.map2XmlString(data);
        String response = WxHttpUtil.ssl4Job(url, mchId, dataXML);
        if (StringUtils.isEmpty(response)) {
            return;
        }

        Document document2 = XmlUtil.getDocument(response);
        Map<String, String> queryMap = new HashMap<>();
        XmlUtil.getMapByDocument(document2.getRootElement(), queryMap);
        String returnCode = queryMap.get("return_code");
        String resultcode = queryMap.get("result_code");
        if ("SUCCESS".equals(returnCode) && "SUCCESS".equals(resultcode)) {
            String status = queryMap.get("status");
            String reason = queryMap.get("reason");

            if ("SUCCESS".equals(status)) {
                // 成功
                ChargingWithdrawCash temp = new ChargingWithdrawCash();
                temp.setId(id);
                temp.setStatus(ChargeAppConstant.WithdrawCashStatus.SUCCESS.getStatus());
                temp.setUpdateTime(new Date());
                chargingWithdrawCashService.updateByPrimaryKeySelective(temp);
            } else if("PROCESSING".equals(status)) {
                // 处理中
                // do nothing
            } else {
                // 转账失败
                ChargingWithdrawCash temp = new ChargingWithdrawCash();
                temp.setId(id);
                temp.setStatus(ChargeAppConstant.WithdrawCashStatus.FAIL.getStatus());
                temp.setErrorMsg(reason);
                temp.setUpdateTime(new Date());
                chargingWithdrawCashService.updateByPrimaryKeySelective(temp);
            }
        }
    }

    /**
     * 根据商户订单号，查询企业付款信息
     * @param request
     * @param partnerTradeNo
     */
    private String queryTransferInfo(HttpServletRequest request,String partnerTradeNo) {
        String url = "https://api.mch.weixin.qq.com/mmpaymkttransfers/gettransferinfo";
        String nonceStr = StringUtil.getNonceStr();
        Map<String, String> data = new HashMap<>();
        data.put("mch_id", mchId);
        data.put("appid",appId);
        data.put("nonce_str",nonceStr);
        data.put("partner_trade_no",partnerTradeNo);

        String sign = WxPaySignatureUtils.signature(data,partnerkey);
        data.put("sign",sign);

        String dataXML = XMLBeanUtils.map2XmlString(data);
        String ssl = WxHttpUtil.ssl(request, url, mchId, dataXML);
        return ssl;
    }
}
